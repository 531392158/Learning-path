## 进位计数值
这里主要讲的是二进制四进制和八进制等常用进制的互相转换。\
因为以前已经学过了，也很简单，暂时按下不表，后续复习如果遇到难点在来这里补充。
## BCD码
用二进制来编码，用十进制来进行运算。\
每四个二进制字符与1个十进制字符**一一对应**
### 8421码的加法运算
由于8421与十进制的映射关系只有1-9，因此当一组8421码进行加法运算时，如果超过了9，就无法在映射表中找到，因此需要进行**加6修正**，也就是加0110。\
![image](https://user-images.githubusercontent.com/57034402/137426995-2e9fbf4b-141b-41b5-9173-70a2f5aa00d3.png)
### BCD码的不同映射方案
原理：4个二进制位映射16种不同的状态。\
BCD码由于指标是0-9，因此只需要使用其中的十种状态，因此靠排列组合可以产生不同的映射方案。
- 余三码：8421码的映射关系+0011
  - ![image](https://user-images.githubusercontent.com/57034402/137427501-4a31c3c4-2e25-47ee-8161-76e8771a7a77.png)
- 2421码：改变权值定位，最高位的权重改为2
  - ![image](https://user-images.githubusercontent.com/57034402/137427547-5aacbe9d-f57f-4735-b9de-fe06194ff2ee.png)
  - 我们拿9来举例，1111中本来第一个1的权重是八，那么1001就是9，现在第一个1的权重变为2，所以是2+111，而111按照二进制来说是7，所以1111就是2+7=9,这也是2421名字的由来。
## 符号
符号的种类
- 数字
- 符号
- 字母
这里主要是ASCII码和7位二进制字符的映射关系，很简单，按下不表。
字符串：多个Asc码组合在一起
- 字符串的存放模式
  - 大端模式：存储单元内先存储高位字节、后存储低位字节的顺序
  - 小段模式：先存储低位字节、后存储高位字节
- 汉字的表示与编码
  - 汉字加各种符号共7445个
  - 区位码：94个区，每区94个位置
## 奇偶校验码
背景：为了解决信息发送过程中的跳变无法被接收方检测而导致的传输错误。\
- 奇校验：保证一段数据中出现奇数个1
- 偶校验：保证一段数据中出现偶数个1
- 实现方式：在编码的首位放入一个奇偶校验位，根据有效信息位中1的个数决定校验位的数据，比如说，如果用的是奇校验，有效信息位中有5个1，那么已经是奇数了，校验位为0，如果是4个，校验位则为1。（相当于凑齐了奇数个1）\
## 海明校验码
奇偶校验码的缺陷：无法检测出偶数个错误。\
海明校验码的设计思路：分组校验-》多个校验位-》校验位标注出错的位置。\
![image](https://user-images.githubusercontent.com/57034402/137429963-333906d4-8364-479b-be15-c7f70959f4a7.png)
## 循环冗余校验码
生成CRC码：
![image](https://user-images.githubusercontent.com/57034402/137430420-8ae002ac-d73a-49de-aead-256aeb10e5fd.png)
检错和纠错：
![image](https://user-images.githubusercontent.com/57034402/137430583-e293f121-6b6e-4ca6-a9d7-e575b3977112.png)

## 无符号数
整个机器字长的全部二进制位数均为数值为，没有符号位，相当于数的绝对值。/
8位无符号数的表示范围：00000000~11111111即 0~255

## 有符号数
机器字长的首位表示正负号，一般0为正 1为负。

## 定点表示
小数点：隐含存储，通常在符号位后面，可以用原码、移码和补码表示定点数。
- 原码：用尾数表示真值的绝对值，符号位“0/1”对应正负，相当于是普通的有符号数的表示方法。
- ![image](https://user-images.githubusercontent.com/57034402/137585733-af7edd43-aaa8-491d-811a-b2a4c2963b7b.png)
- 反码：若符号位为0，则反码与原码相同，符号位为1，则数值为全部取反。
- 补码：正数的补码 = 原码；负数的补码 = 反码末尾+1（要考虑进位）。
- 移码：在补码的基础上将**符号位**取反。（只能表示整数）
- 特别的：对于定点正数，补码 = 10000000 表示- 2^7，对于顶点小数则表示为-1
- 特别的：如果符号位为正，则原码补码和反码都相同
- **原码与补码互相转换**：数值位取反，然后最低位+1即可实现相互转换
![image](https://user-images.githubusercontent.com/57034402/137606834-6f5d4feb-5929-4da0-8f37-120377a9b474.png)
![image](https://user-images.githubusercontent.com/57034402/137606858-600b3358-b05d-48a7-85df-90588f1599ea.png)

## 加减运算
当我们对原码进行加减运算时，必须考虑到符号位。如果计算一个正数+负数，需要将原码转换成正数-正数。/
- 这里不得不提到负数的模运算的性质
- ![image](https://user-images.githubusercontent.com/57034402/137607487-9dc5bb41-352e-4710-9850-3155de7b50a6.png)

### 加减互换
补码的作用：使用补码可以将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算。
![image](https://user-images.githubusercontent.com/57034402/137607706-82e7a79d-a1c5-41a2-be4f-a218fb621f20.png)

## 移位运算

- 原码的运算移位
- ![image](https://user-images.githubusercontent.com/57034402/137608190-2fdc723d-b728-4895-ad2d-40f4b9b1ffab.png)

- 反码的运算移位
  - 正数：与原码一致
  - 负数：与原码相反，因此负数反码的移位运算规则如下：
    - 右移：高位补1，低位舍弃。
    - 左移：低位补1，高位舍弃。
- 补码的算术移位
- 



